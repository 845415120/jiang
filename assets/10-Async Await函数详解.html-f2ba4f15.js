import{_ as e,r as p,o,c,b as n,d as s,e as t,a as i}from"./app-03f59e97.js";const l={},r=i(`<h1 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> async/await</h1><h2 id="async-await-异步函数-概述" tabindex="-1"><a class="header-anchor" href="#async-await-异步函数-概述" aria-hidden="true">#</a> async/await （异步函数）概述</h2><p>async/await 是在 ES8(即ES 2017）中引入的新语法，是另外一种异步编程解决方案。</p><p>本质： 是 Generator 的语法糖。</p><ul><li>async 的返回值是 Promise 实例对象。</li><li>await 可以得到异步结果。</li></ul><p>我们在普通的函数前面加上 async 关键字，就成了 async 函数。</p><p>什么是语法糖呢？语法糖就是让语法变得更加简洁、更加舒服，有一种甜甜的感觉。</p><h2 id="async-await-的基本用法" tabindex="-1"><a class="header-anchor" href="#async-await-的基本用法" aria-hidden="true">#</a> async/await 的基本用法</h2><p>async 后面可以跟一个 Promise 实例对象。代码举例如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">const</span> <span class="token function-variable function">request1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">&#39;https://www.baidu.com/xxx_url&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>retCode <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 这里的 response 是接口1的返回结果</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;request1 success&#39;</span><span class="token operator">+</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&#39;接口请求失败&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">queryData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">request1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">queryData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基于-async-await-处理多次-ajax-请求【重要】" tabindex="-1"><a class="header-anchor" href="#基于-async-await-处理多次-ajax-请求【重要】" aria-hidden="true">#</a> 基于 async/await 处理多次 Ajax 请求【重要】</h2><p>实际开发中，现在有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。</p><p>这种场景其实就是接口的多层嵌套调用。之前学过 Promise，它可以把原本的<strong>多层嵌套调用</strong>改进为<strong>链式调用</strong>。</p><p>而今天要学习的 async/await ，可以把原本的“多层嵌套调用”改成类似于同步的写法，非常优雅。</p><p>代码举例：</p><p>暂略。</p><h3 id="promise、async-await、generator的对比" tabindex="-1"><a class="header-anchor" href="#promise、async-await、generator的对比" aria-hidden="true">#</a> Promise、async...await、Generator的对比</h3><p>我们在使用 Promise、async...await、Generator 的时候，返回的都是 Promise 的实例。</p><p>如果直接使用 Promise，则需要通过 then 来进行链式调用；如果使用 async...await、Generator，写起来更像同步的代码。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>`,20),u={href:"https://www.cnblogs.com/CandyManPing/p/9384104.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://segmentfault.com/a/1190000007535316",target:"_blank",rel:"noopener noreferrer"};function k(v,m){const a=p("ExternalLinkIcon");return o(),c("div",null,[r,n("ul",null,[n("li",null,[n("a",u,[s("js async await 终极异步解决方案"),t(a)])]),n("li",null,[n("a",d,[s("理解 JavaScript 的 async/await"),t(a)])])])])}const w=e(l,[["render",k],["__file","10-Async Await函数详解.html.vue"]]);export{w as default};
