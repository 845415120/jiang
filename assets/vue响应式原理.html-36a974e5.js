import{_ as e,o as t,c as r,a}from"./app-599c9e37.js";const i={},d=a('<h3 id="vue的基本原理" tabindex="-1"><a class="header-anchor" href="#vue的基本原理" aria-hidden="true">#</a> Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34220974/1678713141767-719a328a-c3dc-43d0-af9b-cabf82dc7dd7.png#averageHue=%23f5dc96&amp;clientId=ub2e1406f-05ee-4&amp;from=paste&amp;height=483&amp;id=u50561b78&amp;originHeight=589&amp;originWidth=946&amp;originalType=binary&amp;ratio=1.2200000286102295&amp;rotation=0&amp;showTitle=false&amp;size=189225&amp;status=done&amp;style=none&amp;taskId=u4117aba6-c590-45d3-881c-12d6bf8702b&amp;title=&amp;width=775.4098178814321" alt="image.png"></p><h3 id="_2-双向数据绑定的原理" tabindex="-1"><a class="header-anchor" href="#_2-双向数据绑定的原理" aria-hidden="true">#</a> 2. 双向数据绑定的原理</h3><p>版本1<br>Vue.js 是采用<strong>数据劫持</strong>结合<strong>观察者模式</strong>的方式，通过<br>Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给观察者，触发相应的监听回调。Watcher调用 组件中的 render函数 去生成虚拟DOM 对比老的DOM 通过diff算法以最小的代价更新DOM节点 是页面实现更新</p><p>版本2<br>Object.defineProperty() 里的方法 setter与getter方法的观察者模式来实现<br>一旦属性发生了变化 setter，getter 方法通调用Watcher(观察者) ,Watcher调用 组件中的 render函数 去生成虚拟DOM 对比老的DOM 通过diff算法以最小的代价更新DOM节点 是页面实现更新</p><h1 id="proxy的优势如下" tabindex="-1"><a class="header-anchor" href="#proxy的优势如下" aria-hidden="true">#</a> proxy的优势如下：</h1><ul><li>Proxy 可以直接监听对象而非属性，可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li></ul>',8),n=[d];function o(p,c){return t(),r("div",null,n)}const h=e(i,[["render",o],["__file","vue响应式原理.html.vue"]]);export{h as default};
